# 五层因特网协议栈

## 应用层

网络应用程序及它们的应用层协议存留的地方。

位于应用层的信息分组称为**报文（message）**

应用层协议:

- HTTP:提供Web文档请求和传送

- SMTP:提供电子邮件报文的传输

- FTP：它提供两个端系统之间的文件传送

## 运输层

在应用程序端点之前传送应用层报文。

位于传输层的信息分组称为**报文段（segment）**

运输层协议：

- TCP:提供可靠连接、**流量控制**（发送方和接收方速率匹配）、**拥塞控制机制**

- UDP:无连接服务。没有TCP的三种机制。

## 网络层

负责将**数据报**从一台主机移动到另一台主机。

在一台源主机的运输层协议（TCP和UDP）向网络层递交运输层**报文段和目的地址**。

位于网络层的信息分组称为**数据报（datagram）**

- IP协议

## 链路层

将帧从当前节点（主机或路由器）传递给下一个节点（路由器）

提供下一个节点（路由器）地址

位于链路层的信息分组称为**帧（frame）**

## 物理层

将**帧**的一个一个bit移动到下一个节点

![](assets/2022-11-27-21-04-38-image.png)

## 封装

每一层，一个分组具有两种类型的字段：首部字段和**有效载荷字段(payload field)**，有效载荷字段通常来自上一层的分组。

# 应用层

## 应用层体系结构

### 客户-服务器体系结构

服务器，服务于来自许多其他称为客户的主机的请求。一个经典的例子是Wb应用程序，其中总是打开的Wb服务器服务于来自浏览器（运行在客户主机上）的请求。当Web服务器接收到来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响应。

- 客户-服务器体系结构中，**客户相互之间不直接通信**；例如，在Web应用中两个浏览器并不直接通信。

- 服务器具有固定的、周知的地址，该地址称为IP地址。

具有客户-服务器体系结构的非常著名的应用程序包括Web、FTP、Telnet和电子邮件。

### P2P体系结构

应用程序之间直接通信。

## 进程通信

应用程序的通信实际上是**进程（process）**

**一个进程可以被认为是运行在端系统中的一个程序**。当进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。进程间通信的规则由端系统上的操作系统确定。

在两个不同端系统上的进程，通过跨越计算机网络交换**报文**（**message**）而相互通信。

### 客户和服务器进程

网络应用程序由成对的进程(**客户(client)和服务器(server)**)组成，这些进程通过网络相互发送报文。

发起通信的进程是**客户**，等待联系的进程是**服务器**

例如：

- Web中，浏览器是一个**客户进程**、Web服务器是一台**服务器进程**。

- P2P文件共享中，下载文件的对等方是**客户**，上载文件的对等方是**服务器**

### 进程与计算机网络之间的接口

从一个进程向另一个进程发送的报文必须通过下面的运输层。进程通过**套接字（socket）** 软件接口向运输层发送报文和接收报文。

![](assets/2022-11-28-14-27-02-image.png)

### 进程寻址

接收进程需要有一个地址。需要两个信息：

1. 主机地址

2. 定义在目的主机中的接收进程的标识符

主机由**IP地址**标识。是32bit信息

接收进程有**端口号（port number）** 确定。

已经流行的应用分配了特定端口号。例如：

- Web服务器用端口号80来标识。

- 邮件服务器进程（使用SMTP协议）用端口号25来标识。

## 可供应用程序使用的运输服务

一个运输层协议能够为调用它的应用程序提供什么样的服务呢？我们大体能够从四个方面对应用程序服务要求进行分类：**可靠数据传输**、**吞吐量**、**定时**和**安全性**。因特网中实际上没有针对吞吐量和定时的运输层协议。

![](assets/2022-11-28-14-45-16-image.png)

### TCP服务

TCP服务模型包括面向连接服务和可靠数据传输服务。且提供拥塞控制机制。

TCP和UDP都没有任何加密机制。现在已经研制出加强版的TCP，通过**安全套接字层（Secure Sockets Layer）** 加强TCP。注意**这种加强是在应用层上进行加强**。

### UDP服务

不需要握手、不可靠数据传输服务。不提供拥塞控制机制。

## 应用层协议

### HTTP概述

Web的应用层协议是**超文本传输协议**（HyperText Transfer Protocol，HTTP)

#### Web页面

由对象组成。对象可以是HTML文件、JPEG、视频或程序等，它们可以通过一个URL地址寻址。

> 例如，一个Web页面包括HTML文本和5个JPEG，这个Web页面有6个对象。HTML基本文件通过对象的URL地址引用页面中的其他对象。每个URL地址由两部分组成:存放对象的服务器主机名和对象的路径名。
> 
> 例如
> 
> `http://www.someSchool.edu/someDepartment/picture.gif`,
> 
> 其中`www.someSchool.edu`就是主机名，`/someDepartment/picture.gif`就是路径名。

浏览器其实就是HTTP客户端，Web服务器是HTTP的服务器端，存储Web对象，每个对象由URL寻址。

#### HTTP

HTTP定义了Web客户向Web服务器请求Web页面的方式。HTTP使用TCP作为它的支撑运输协议。一旦连接建立，浏览器和服务器进程通过套接字访问TCP。

HTTP服务器不保存客户任何信息，所以HTTP属于**无状态协议（stateless protocol）**

#### 非持续连接和持续连接

从服务器向客户传送一个Web页面（包括1个HTML基本文件和10个JPEG图形）。HTML基本文件的URL为`http://www.someSchool.edu/someDepartment/home.index`

**采用非持续连接的HTTP**

- HTTP客户进程在端口号80发起一个到服务器`www.someSchool.edu`的TCP连接。80是HTTP默认端口号。

- HTTP客户经它的套接字向该服务器发送一个HTTP请求报文。请求报文包含了路径名`/someDepartment/home.index`

- HTTP服务器进程经它的套接字接收改请求报文，从服务器本地检索出`www.someSchool.edu/someDepartment/home.index`，在一个HTTP响应报文中封装对象，并通过其套接字向客户发送响应报文。

- HTTP服务器进程通知TCP断开该TCP连接。（但是直到TCP确认客户已经完整接收到报文为止）

- HTTP客户接收响应报文，TCP连接关闭。客户从响应报文中提取改文件，检查该HTML文件，得到对10个JPEG图形的引用。

- 对每个引用的JPEG图形对象重复前4个步骤。

上面的步骤举例说明了非持续连接的使用，其中每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。值得注意的是每个TCP连接只传输一个请求报文和一个响应报文。因此在本例中，当用户请求该Wb页面时，要产生11个TCP连接。

**持续连接的HTTP**

在采用持续连接的情况下，服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。

> 特别是，一个完整的Web页面(上例中的HTML基本文件加上10个图形)可以用单个持续TCP连接进行传送。
> 
> 更有甚者，位于同一台服务器的多个Web页面在从该服务器发送给同一个客户时，可以在单个持续TCP连接上进行。可以一个接一个地发出对对象的这些请求，而不必等待对未决请求（流水线）的回答。
> 
> 一般来说，如果一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，HTTP服务器就关闭该连接。HTTP的默认模式是使用带流水线的持续连接。

### HTTP报文格式

#### 请求报文

典型的HTTP请求报文：

![](assets/2022-11-28-15-47-04-image.png)

![](assets/2022-11-28-15-43-05-image.png)

#### 响应报文

![](assets/2022-11-28-15-50-57-image.png)

![](assets/2022-11-28-15-50-33-image.png)

![](assets/2022-11-28-15-51-12-image.png)

状态码：

- 200 OK:请求成功，信息在返回的响应报文中。

- 301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL。

- 400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解。

- 404 Not Found：被请求的文档不在服务器上。

- 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。

### 用户与服务器的交互：cookie

HTTP服务器是无状态的，无法保存客户信息。为此，HHTP使用了cookie。

用户请求服务器时，服务器接收到会标识用户，给用户赋ID，下次请求服务器，服务器会识别。

### Web缓存

**Web缓存器(Web cache)** 也叫**代理服务器(proxy server)**。它能够代表初始Web服务器来满足HTTP请求的网络实体。

当客户请求代理服务器，代理服务器有的返回给客户，没有的向初始服务器请求，接收到时在代理服务器本地存一份副本，再返回给客户。

因此，代理服务器即使服务器又是客户。

![](assets/2022-11-29-18-10-27-image.png)

代理服务器可以大大缓解流量压力，降低时延。

![](assets/2022-11-29-18-48-23-image.png)

### 条件GET方法

- 首先代理缓存器代表浏览器向Web服务器发送请求报文。

![](assets/2022-11-29-18-54-30-image.png)

- Web服务器向缓存器发送具有被请求的对象的响应报文

![](assets/2022-11-29-18-55-59-image.png)

- 该缓存器将对象转发到浏览器并缓存到本地。同时存储该对象最后修改时间。下次浏览器请求同一个对象，缓存器确保对象是否已经修改，向服务器发送**条件GET**执行最新查询。

![](assets/2022-11-29-18-56-15-image.png)

- Web服务器仍会发送一个响应代码，状态码：304 Not Modified，说明没有修改。

![](assets/2022-11-29-19-00-51-image.png)

### 文件传输协议：FTP

### 电子邮件传输协议：SMTP

### DNS：因特网的目录服务

由主机名到IP地址转换的目录服务。

DNS也属于应用层协议

DNS工作机理概述

假设运行在用户主机上的某些应用程序(如Wb浏览器或邮件阅读器)需要将主机名转换为IP地址。这些应用程序将调用DNS的客户端，并指明需要被转换的主机名（在很多基于UNIX的机器上，应用程序为了执行这种转换需要调用函数gethostbyname（）).
用户主机上的DNS接收到后，向网络中发送一个DNS查询报文。所有的DNS请求和回答报文**使用UDP**数据报经**端口53**发送。经过若干毫秒到若干秒的时延后，用户主机上的DNS接收到一个提供所希望映射的DNS回答报文。这个映射结果则被传递到调用DNS的应用程序。

![](assets/2022-11-29-20-10-56-image.png)

三种类型DNS服务器：

- 根DNS服务器

- 顶级域(Top-Level Domain，TLD)DNS服务器和权威服务器。负责顶级域名如`com`、`org`、`net`、`edu`和`gov`以及所有国家的顶级域名如`uk`、`fr`等

- 权威DNS服务器

![](assets/2022-11-29-20-12-09-image.png)

![](assets/2022-11-29-20-32-05-image.png)

## TCP套接字编程

```python
# TCPClient.py
from socket import *
serverName = 'servername'
serverPort = 12000
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName,serverPort))
sentence = raw_input('Input lowercase sentence:')
clientSocket.send(sentence)
modifiedSentence = clientSocket.recv(1024)
print('From Server:',modifiedSentence)
clientSocket.close()
```

```python
# TCPServer.py
from socket import *
serverPort = 12000
serverSocket = socket(AF_INET,SOCK_STREAM)
serverSocket.bind(('',serverPort))

# 让服务器聆听来自客户的TCP连接请求。请求连接的最大数(至少为1)
serverSocket.listen(1)
print('The server is ready to receive')
while(1){
    connectionSocket,addr = serverSocket.accept()
    sentence = connectionSocket.recv(1024)
    capitalizedSentence = sentence.upper()
    connectionSocket.send(capitalizedSentence)
    connectionSocket.close()
}
```

![](assets/2022-11-30-19-09-37-image.png)

# 运输层

## 多路复用与多路分解

- 将运输层报文段中的数据交付到正确的套接字的工作称为**多路分解(demultiplexing)**。

- 源主机从不同套接字中手机数据块并封装上首部信息从而生成报文段，然后将报文段传递给网络层，这个过程称为**多路复用(multiplexing)**

端口号是16bit数(0~65535之间)，其中0~1023范围的端口号是**周知端口号(well-known port number)**，例如HTTP的端口号是80，FTP的端口号是21。

<img title="" src="assets/2022-12-01-19-01-18-image.png" alt="" data-align="center">

![](assets/2022-12-01-19-07-14-image.png)

## 无连接运输：UDP

UDP的优点

- **实时性**：采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即传递给网络层。在另一方面，TCP有一个拥塞控制机制。当链路变得拥塞时来遏制TCP发送方，导致TCP继续重新发送数据报文段指导目的主机收到并加以确认，交付时间可能需要很长。

- **无需建立连接**:耗时短。

- **无连接状态**：

- **分组首部开销小**：每个TCP报文段有20字节的首部开销，UDP仅有8字节的开销。

### UDP报文段结构

长度字段是指包括首部在内的UDP报文段长度（以字节为单位）。

<img src="assets/2022-12-01-19-25-45-image.png" title="" alt="" data-align="center">

## TCP(Transmission Control Protocol)

- 第一次握手： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；  

- 第二次握手： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；  

- 第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

![](F:\github\DLnotes\code_note\计算机网络\assets\tcp.jpg)

# 

# 网络层


