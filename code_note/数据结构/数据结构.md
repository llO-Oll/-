# 哈希表

哈希表-散列表， 它是基于快速存储的角度设计的，也是一种典型的“空间换时间”的做法。

![在这里插入图片描述](https://i.loli.net/2021/11/23/wziyX7lUJB8Nxo4.png)

 

# 动态规划(Dynamic Programming)

DP在查找有很多重叠子问题的情况的最优解时有效。

**它将问题重新组合成子问题。**

**为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。**因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间 · · · · · · 动态规划只能应用于有最优 子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。”

通俗一点来讲，动态规划和其它遍历算法（如深/广度优先搜索）都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存子问题的解，避免重复计算。解决动态规划问题的关键是找到状态转移方程，这样我们可以通过计算和储存子问题的解来求解最终问题。

## 122.Best Time to Buy and Sell Stock II (Easy)

![image-20220114161913223](C:\Users\13603\AppData\Roaming\Typora\typora-user-images\image-20220114161913223.png)

```c++
//122. Best Time to Buy and Sell Stock II (Easy)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        int dp[n][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[n-1][0];
    }
};
```

# 二分查找

时间复杂度为`O(log n)`

**求左边界：向下取整，等号归右，左加一
求右边界：向上取整，等号归左，右减一**
**总是右侧为所求**

求左边界

```c++
int left = 0,right = n-1;
while(left < right){
//求左边界(注意这里不要等号)
	int mid = (left+right)>>1;//向下取整;>>1:结果右移一位，=结果/2
    if(nums[mid]>=target)
        right = mid;			//等号归右
    else
        left = mid+1;			//左加一   
}//此时right即为所求
```

求右边界

```c++
int left = 0,right = n-1;
while(left<right){
	int mid = (left + right +1)>>1;		//向上取整
    if(num[mid] <= target) 
        left = mid;		
    else
        right = mid-1;
}//此时right即为所求
```

## 34.在排序数组中查找元素的第一个和最后一个位置

```
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
进阶：
你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

示例 1：
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

示例 2：
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

示例 3：
输入：nums = [], target = 0
输出：[-1,-1]
```

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> result={-1,-1};
        int n=nums.size();
        //空字符串
        if(n==0){
            return result;
        }
        //求左边界
        int left=0,right=n-1,mid;
        while(left<right){
            mid=(left+right)>>1;
            if(nums[mid]>=target){
                right=mid;
            }
            else 
                left=mid+1;
        }
        if(nums[right]==target)
            result[0]=right;
        //求右边界
        left=0,right=n-1;    
        while(left<right){
            mid=(left+right+1)>>1;
            if(nums[mid]<=target){
                left=mid;
            }
            else 
                right=mid-1;           
        }
        if(nums[right]==target)
            result[1]=right;
        return result;
    }
};
```

## 81.搜索旋转排序数组Ⅱ

![image-20220208163932331](F:\github\DLnotes\code_note\数据结构\数据结构.assets\image-20220208163932331-16443095786821.png)

```c++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
    	int left=0,right=nums.size()-1,mid;
        while(left<=right){
            mid=(left+right)>>1;
            if(nums[mid]==target)
                return true;
            
            //如果无法判断哪边为递增序列，left++
            if(nums[left]==nums[mid])
                left++;
            
            //右序列为递增序列
            else if(nums[mid]<=nums[right]){
                if(nums[left]<=target&&target<nums[mid])
                    right=mid;
                else 
                    left=mid+1;
            }
            //左序列为递增序列
            else{
                if(nums[left]<=target&&target<nums[mid])
                    right=mid;
                else 
                    left=mid+1;
            }   
        }
    }
}
```

## 4.寻找两个有序数组的中位数

> 给定两个大小分别为 m 和 n 的正序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的 中位数 。
>
> 算法的时间复杂度应该为 O(log (m+n)) 。
>
> 示例 1：
>
> 输入：nums1 = [1,3], nums2 = [2]
> 输出：2.00000
> 解释：合并数组 = [1,2,3] ，中位数 2
> 示例 2：
>
> 输入：nums1 = [1,2], nums2 = [3,4]
> 输出：2.50000
> 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5

- 使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。

- 不需要合并数组，只要找到中位数位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。

维护两个指针，初始时分别指向两个数组的下标0的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。

因此我们可以归纳出三种情况：

1. 如果`A[K/2-1]<B[K/2-1]`,则比`A[K/2-1]`小的数最多只有A的前`K/2-1`个数，即比`A[K/2-1]`小的数最多只有`k-2`个，因此`A[K/2-1]`不可能是第K个数，`A[0]`到`A[K/2-1]`也不可能是第k个数，可以全部排除。
2. 如果`A[K/2-1]>B[K/2-1]`，则可以排除`B[0]`到`B[K/2-1]`。
3. 如果`A[K/2-1]=B[K/2-1]`，则可以归入第一种情况处理。

可以看到，比较`A[K/2-1]`和`B[K/2-1]`后，可以排除`k/2`个不可能是第`k`小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少`k`的值，这是因为我们排除的数都不大于第`k`小的数。

有以下三种情况需要特殊处理：

1. `A[K/2-1]`或者`B[K/2-1]`越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少k的值，而不能直接将k减去k/2。
2. 如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第k小的元素。
3. 如果k=1,我们只要返回两个数组首元素的最小值即可。



```c++
class Solution {
public:
    int getKthElement(const vector<int>& nums1, const vector<int>& nums2, int k) {
        /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
         * 这里的 "/" 表示整除
         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
         * 这样 pivot 本身最大也只能是第 k-1 小的元素
         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
         */

        int m = nums1.size();
        int n = nums2.size();
        int index1 = 0, index2 = 0;

        while (true) {
            // 边界情况
            if (index1 == m) {
                return nums2[index2 + k - 1];
            }
            if (index2 == n) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return min(nums1[index1], nums2[index2]);
            }

            // 正常情况
            int newIndex1 = min(index1 + k / 2 - 1, m - 1);
            int newIndex2 = min(index2 + k / 2 - 1, n - 1);
            int pivot1 = nums1[newIndex1];
            int pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= newIndex1 - index1 + 1;
                index1 = newIndex1 + 1;
            }
            else {
                k -= newIndex2 - index2 + 1;
                index2 = newIndex2 + 1;
            }
        }
    }

    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int totalLength = nums1.size() + nums2.size();
        if (totalLength % 2 == 1) {
            return getKthElement(nums1, nums2, (totalLength + 1) / 2);
        }
        else {
            return (getKthElement(nums1, nums2, totalLength / 2) + getKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0;
        }
    }
};



```



# 排序

## 快速排序

1. `i=L,j=R`;将基准数挖出形成第一个坑`a[i]`。
2. `j--`由后向前找出比它小的数，找到后挖出此数填前一个坑`a[i]`。
3. `i++`由前向后找到比它大的数，找到后也挖出此数填到前一个坑`a[j]`中。
4. 再重复执行2、3二步，直到i==j，再将基准填入`a[j]`中。

```c++
void quick_sort(int s[], int l , int r)
{
	if(l < r){
		int i = l,i = r,x = s[l];
		while(i < j)
		{
			while(i < j && s[j] >= x)
				j--;
			if(i < j)
				s[i++] = s[j];
			while(i < j && s[i] < x)
				i++;
			if(i < j)
				s[j--] = s[i];
		}
		s[i] = x;
		quick_sort(s,l,i-1);
		quick_sort(s,i+1,r);
	}
}
```



## 快速选择

### 215. Kth  Largest Element in an Array

快速选择一般用于求解 k-th Element 问题，可以在 *O*(*n*) 时间复杂度，*O*(1) 空间复杂度完成求解工作。快速选择的实现和快速排序相似，不过只需要找到第 *k* 大的枢（pivot）即可，不需要对其左右再进行排序。与快速排序一样，快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为 *O*(*n*2)，我们这里为了方便省略掉了打乱的步骤。

```c++
// 主函数
int findKthLargest(vector<int>& nums, int k) {
int l = 0, r = nums.size() - 1, target = nums.size() - k;
	while (l < r) {
		int mid = quickSelection(nums, l, r);
		if (mid == target) {
			return nums[mid];
		}
		if (mid < target) {
			l = mid + 1;
		} else {
			r = mid - 1;
		} 
    }
	return nums[l];
}
// 辅函数 - 快速选择
int quickSelection(vector<int>& nums, int l, int r) {
	int i = l + 1, j = r;
	while (true) {
        while (i < r && nums[i] <= nums[l]) {
            ++i;
        }
        while (l < j && nums[j] >= nums[l]) {
            --j;
        }
        if (i >= j) {
            break; 
        }
        swap(nums[i], nums[j]);
    }
	swap(nums[l], nums[j]);
	return j;
}
```

## 桶排序

### 347.前k个高频元素

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。
>
> ```
> 示例 1:
> 输入: nums = [1,1,1,2,2,3], k = 2
> 输出: [1,2]
> 
> 示例 2:
> 输入: nums = [1], k = 1
> 输出: [1]
> ```

首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个“出现次数数组”。找出原数组的前k个高频元素，就相当于找出“出现次数数组”的前k大的值。

最简单的做法是给「出现次数数组」排序。但由于可能有`O(N)`个不同的出现次数（其中`N`为原数组长度），故总的算法复杂度会达到`O(Nlog N)`，不满足题目的要求。

在这里，我们可以利用堆的思想：建立一个小顶堆，然后遍历「出现次数数组」：

如果堆的元素个数小于`k`，就可以直接插入堆中。
如果堆的元素个数等于 `k`，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 `k` 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。

```c++
public:
    static bool cmp(pair<int, int>& m, pair<int, int>& n) {
        return m.second > n.second;
    }

    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> occurrences;
        for (auto& v : nums) {
            occurrences[v]++;
        }

        // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);
        for (auto& [num, count] : occurrences) {
            if (q.size() == k) {
                if (q.top().second < count) {
                    q.pop();
                    q.emplace(num, count);
                }
            } else {
                q.emplace(num, count);
            }
        }
        vector<int> ret;
        while (!q.empty()) {
            ret.emplace_back(q.top().first);
            q.pop();
        }
        return ret;
    }
};

```

