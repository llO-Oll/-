# 哈希表

哈希表-散列表， 它是基于快速存储的角度设计的，也是一种典型的“空间换时间”的做法。

![在这里插入图片描述](https://i.loli.net/2021/11/23/wziyX7lUJB8Nxo4.png)

 

# 动态规划(Dynamic Programming)

DP在查找有很多重叠子问题的情况的最优解时有效。

**它将问题重新组合成子问题。**

**为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。**因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间 · · · · · · 动态规划只能应用于有最优 子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。”

通俗一点来讲，动态规划和其它遍历算法（如深/广度优先搜索）都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存子问题的解，避免重复计算。解决动态规划问题的关键是找到状态转移方程，这样我们可以通过计算和储存子问题的解来求解最终问题。

## 122.Best Time to Buy and Sell Stock II (Easy)

![image-20220114161913223](C:\Users\13603\AppData\Roaming\Typora\typora-user-images\image-20220114161913223.png)

```c++
//122. Best Time to Buy and Sell Stock II (Easy)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        int dp[n][2];
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[n-1][0];
    }
};
```

# 二分查找

时间复杂度为`O(log n)`

**求左边界：向下取整，等号归右，左加一
求右边界：向上取整，等号归左，右减一**
**总是右侧为所求**

求左边界

```c++
int left = 0,right = n-1;
while(left < right){
//求左边界(注意这里不要等号)
	int mid = (left+right)>>1;//向下取整;>>1:结果右移一位，=结果/2
    if(nums[mid]>=target)
        right = mid;			//等号归右
    else
        left = mid+1;			//左加一   
}//此时right即为所求
```

求右边界

```c++
int left = 0,right = n-1;
while(left<right){
	int mid = (left + right +1)>>1;		//向上取整
    if(num[mid] <= target) 
        left = mid;		
    else
        right = mid-1;
}//此时right即为所求
```

## 34.在排序数组中查找元素的第一个和最后一个位置

```
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
进阶：
你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

示例 1：
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

示例 2：
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

示例 3：
输入：nums = [], target = 0
输出：[-1,-1]
```

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> result={-1,-1};
        int n=nums.size();
        //空字符串
        if(n==0){
            return result;
        }
        //求左边界
        int left=0,right=n-1,mid;
        while(left<right){
            mid=(left+right)>>1;
            if(nums[mid]>=target){
                right=mid;
            }
            else 
                left=mid+1;
        }
        if(nums[right]==target)
            result[0]=right;
        //求右边界
        left=0,right=n-1;    
        while(left<right){
            mid=(left+right+1)>>1;
            if(nums[mid]<=target){
                left=mid;
            }
            else 
                right=mid-1;           
        }
        if(nums[right]==target)
            result[1]=right;
        return result;
    }
};
```

## 81.搜索旋转排序数组Ⅱ

![image-20220208163932331](F:\github\DLnotes\code_note\数据结构\数据结构.assets\image-20220208163932331-16443095786821.png)

```c++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
    	int left=0,right=nums.size()-1,mid;
        while(left<=right){
            mid=(left+right)>>1;
            if(nums[mid]==target)
                return true;
            
            //如果无法判断哪边为递增序列，left++
            if(nums[left]==nums[mid])
                left++;
            
            //右序列为递增序列
            else if(nums[mid]<=nums[right]){
                if(nums[left]<=target&&target<nums[mid])
                    right=mid;
                else 
                    left=mid+1;
            }
            //左序列为递增序列
            else{
                if(nums[left]<=target&&target<nums[mid])
                    right=mid;
                else 
                    left=mid+1;
            }   
        }
    }
}
```

