# 传统图像处理算法

## Canny边缘检测

是John Canny在1986年提出的。它是一个多阶段的算法，即由多个步骤构成。

**1.图像降噪**  
**2.计算图像梯度**  
计算图像梯度，得到可能边缘。计算图像梯度能够得到图像的边缘，因为梯度是灰度变化明显的地方，而边缘也是灰度变化明显的地方。当然这一步只能得到可能的边缘。因为灰度变化的地方可能是边缘，也可能不是边缘。这一步就有了所有可能是边缘的集合。

**3.非极大值抑制**  

通常灰度变化的地方都比较集中，将局部范围内的梯度方向上，灰度变化最大的保留下来，其它的不保留，这样可以剔除掉一大部分的点。将有多个像素宽的边缘变成一个单像素宽的边缘。即“胖边缘”变成“瘦边缘”。

**4.阈值筛选**

双阈值筛选。通过非极大值抑制后，仍然有很多的可能边缘点，进一步的设置一个双阈值，即低阈值（low），高阈值（high）。灰度变化大于high的，设置为强边缘像素，低于low的，剔除。在low和high之间的设置为弱边缘。进一步判断，如果其领域内有强边缘像素，保留，如果没有，剔除。

## 滤波器

### 均值滤波

将一个窗口区域中的像素**计算平均值**，然后将窗口中计算得到的均值设置为锚点上的像素值。

### 中值滤波

取卷积核当中所覆盖像素中的**中值**作为锚点的像素值。

### 高斯滤波

高斯滤波是一种线性滤波，是常用的一种滤波算法，利用二维高斯函数的分布方式来对图像进行平滑。

高斯滤波的优点可以集中在高斯函数的特点上来看

- 首先，二维高斯函数是旋转对称的，在各个方向上平滑程度相同，不会改变原图像的边缘走向。

- 第二，高斯函数是单值函数，高斯卷积核的锚点为极值，在所有方向上单调递减，锚点像素不会受到距离锚点较远的像素影响过大，保证了特征点和边缘的特性。

- 第三，在频域上，滤波过程中不会被高频信号污染。

有一个地方要注意：

- 高斯模糊实质上就是一种均值模糊，只是高斯模糊是按照加权平均的，距离越近的点权重越大，距离越远的点权重越小。通俗的讲，高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。

## 直线检测

### 霍夫变换

假设有一条直线，原点到该直线的垂直距离为$\rho$，垂线与x轴的夹角为$\theta$，那么这条直线是**唯一**的，且直线方程为:

$$
\rho = x\cos\theta + y \sin \theta
$$

其中直线上的每个点，在参数空间都可表示为一条**正弦曲线(sinusoidal curve)。**如图右三条蓝线所对应的便是xy坐标系中直线上三点p1p2p3，在**参数空间**中这三条正弦曲线会交于一点，即图中点(0.92, 9.66)，

![](https://pic1.zhimg.com/80/v2-44a3a72c2cf4c2b0f6a1dde2190ede58_720w.webp)

我们可以发现其实可看成在累加空间(accumulator space)计算**局部最大值**，进行直线的预测。在现实的应用场景中，许多直线并不是非常精细，或多或少**存在偏差**，导致参数空间各曲线不能交于精确的一点，因此我们需要将参数空间分块，分块的步长则为单位长度的$\rho$和$\theta$，如图所示，其次计算单位区域内累加的交点数量，将大于**阈值(threshold)** 的区域值认定为直线存在。

![](https://pic4.zhimg.com/v2-e9c53834a1746b3b9f1dcbb872baa987_r.jpg)

但是还存在一个问题，分块的步长对检测的**精准度**也有影响，分的太细，**计算代价**就会上升，分的太大，计算的准确率就会下降，因此现在通用的常用做法是：$\rho$步长设为单像素单位， $θ$ 步长设为$\frac{\pi}{180} $。

```python
cv2.HoughLinesP(image, rho, theta, threshold, minLineLength,maxLineGap)
"""
Args:
    image：输入图像，通常为canny边缘检测处理后的图像
    rho：线段以像素为单位的距离精度
    theta：像素以弧度为单位的角度精度(np.pi/180较为合适)
    threshold：霍夫平面累加的阈值
    minLineLength：线段最小长度(像素级)
    maxLineGap：最大允许断裂长度
"""
```

### LSD

检测图像中的直线其实就是寻找图像中梯度变化较大的像素。

因此，梯度和图像的**level-line**是LSD提及的两个基本概念。LSD首先计算每一个像素与level-line的夹角以构成一个level-line场。然后，合并这个场里方向近似相同的像素，这样可以得到一系列regions，这些 regions被称为 **line support regions**。如下图所示。

![](https://img-blog.csdn.net/20130820130426156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9sbHlfeWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

每一个**line support region**其实就是一组像素，它也是直线段（line segment）的候选。同时，对于这个line support region，我们可以观察它的最小外接矩形。直观上来讲，当一组像素构成的区域，特别细长时，那么这组像素更加可能是直线段。基于此，作者还统计了line support region的最小外接矩形的主方向。line support region中的一个像素的level-line 角度与最小外接矩形的主方向的角度差在容忍度（tolerance）2τ内的话，那么这个点被称作"aligned point"。作者统计最小外接矩形内的所有像素数和其内的alinedg points数，用来判定这个line support region是否是一个直线段。判定的准则使用的是“a contrario approach”和“Helmholtz principle”方法。在这里，aligned  points的数量是我们感兴趣的信息。因此作者考虑如下假设：aligned points越多，那么region越可能是直线段。对于一副图像i和一个矩形r，记k(i,r)为aligned points的数量，n(r)为矩形r内的总像素数。

LSD算法实现步骤：

1. 图像缩放。

将输入图像源缩小至原图像的80%，减弱或消除图像中的锯齿效应，利用高斯下采样的方式对输入图像进行操作。图像首先与高斯核卷积来平滑消除锯齿效应，然后进行降采样操作，防止其他干扰噪声。高斯核的标准差
o=51a,其中5为缩放因子，a设置为0.6.

2. 计算梯度。

图像的梯度计算是通过2×2模板完成的，较小模板也使得计算相对较快，同时也保证了邻域方向分布的相对独立性。对于灰度图像$f(i,j)$，图像的梯度由下式可得：

$$
grad_x(x,y)=\frac{f(x+1,y)+f(x+1,y+1)-f(x,y)-f(x,y+1)}{2} \\
grad_y(x,y)=\frac{f(x+1,y)+f(x+1,y+1)-f(x,y)-f(x+1,y)}{2}
$$

图像梯度的幅值$G$及行列线的角度$\theta$可由下式得到：

$$
G = \sqrt{{grad_x}^2(x,y)+{grad_y}^2(x,y)}\\
\theta = \arctan(-\frac{grad_x(x,y)}{grad_y(x,y)})
$$

$$

3. 梯度排序

梯度幅值剧烈变化的像素点区域一般是图像中较强边缘存在的区域，LSD算法中区域像素点的处理将会直接影响后续的梯度检测，中间像素一般具有最高的梯度幅值，需要将像素点梯度幅值进行从大到小的排序，进而可
以完成直线检测。LSD中实现的排序算法是伪排序算法，可在线性时间内完成。等间距均匀设置种子点，像素按照对应幅值归类到种子区域，然后利用像素映射关系对梯度幅值进行排序。

4. 梯度阈值

梯度幅值较小的像素点区域对应图像中的平坦区域，较小梯度值点往往出现在平滑区域，不在关注的范围内，但是它们的存在往往会严重影响直线角度的计算。对平坦区域像素值计算其梯度时，很有可能出现更多的误差，因此在LSD计算中，对于梯度幅值小于Ψ的像素点将限制参与支撑线区域的计算。

5. 区域生成

在排序像素列表中选取状态为未使用的像素值点作为种子点，搜索角度满足状态为未使用的点8邻域形成的区域生成支撑线区域。邻域内的角度误差范围为$\tau$，像素将依次被添加到该区域内进行验证更新，种子点的行列线角度为$I_\theta$，区域的角度更新为$\arctan(\frac{\sum_j\sin(l_j)}{\sum_j\cos(l_j)})$，其中$l_j$为行列线区域角度。根据实验得出$\tau$设置为$π/8$则为最优参数。

6. 矩形估计

支撑线区域的外接矩形对应于直线分割，在分割步骤实施之前，应先计算出矩形区域的中心，根据像素的梯度幅值，矩形区域的主轴方向将会被设置为矩形的最小特征向量值对应的角度。

算法步骤

> 输入：    灰度图像$I$,采样率$S$
